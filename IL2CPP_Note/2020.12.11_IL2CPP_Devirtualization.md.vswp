vnote_backup_file_826537664 I:/OneDrive/vnote_notebooks/unity3d/IL2CPP/2020.12.11_IL2CPP_Devirtualization.md
# 2020.12.11_IL2CPP_Devirtualization

现代编译器在执行许多优化以提高运行时代码性能方面表现出色。作为开发人员，我们通常可以通过向编译器显式显示我们所知道的代码信息来帮助编译器。今天，我们将详细探讨 IL2CPP 的一个微型优化，并了解它如何提高现有代码的性能。

## Devirtualization

没有其他方法可以说，虚方法调用总是比直接的方法调用开销更大。我们一直在研究 libil2cpp 运行时库中的一些性能改进，以减少虚拟方法调用的开销(在下一篇文章中将详细介绍) ，但是它们仍然需要某种形式的运行时查找。编译器无法知道在运行时将调用哪个方法——或者它可以吗？

去虚拟化是一个常见的编译器最佳化/服务策略，它将虚拟方法调用变为直接的方法调用。当编译器能够精确地证明在编译时将调用哪个实际方法时，它可能会采用这种策略。不幸的是，这个事实通常很难证明，因为编译器并不总是能看到整个代码库。但是如果可能的话，它可以使虚方法调用更快。

## The canonical example

```c#
public abstract class Animal {
  public abstract string Speak();
}

public class Cow : Animal {
   public override string Speak() {
       return "Moo";
   }
}

public class Pig : Animal {
    public override string Speak() {
        return "Oink";
   }
}

public class Farm: MonoBehaviour {
   void Start () {
       Animal[] animals = new Animal[] {new Cow(), new Pig()};
       foreach (var animal in animals)
           Debug.LogFormat("Some animal says '{0}'", animal.Speak());

       var cow = new Cow();
       Debug.LogFormat("The cow says '{0}'", cow.Speak());
   }
}
```

这里的每个 Speak 调用都是一个虚方法调用。让我们看看我们是否能够说服 IL2CPP 去虚拟化这些方法调用中的任何一个来提高它们的性能。


## Generated C++ code isn’t too bad

我喜欢 IL2CPP 的一个特性是它生成 c + + 代码而不是汇编代码。当然，这段代码看起来不像你手工编写的 c + + 代码，但是它比汇编更容易理解。让我们看一下 foreach 循环主体生成的代码:

```c++
// Set up a local variable to point to the animal array
AnimalU5BU5D_t2837741914* L_5 = V_2;
int32_t L_6 = V_3;
int32_t L_7 = L_6;

// Get the current animal from the array
V_1 = ((L_5)->GetAt(static_cast<il2cpp_array_size_t>(L_7)));
Animal_t3277885659 * L_9 = V_1;

// 虚函数调用
// Call the Speak method
String_t* L_10 = VirtFuncInvoker0< String_t* >::Invoke(4 /* System.String AssemblyCSharp.Animal::Speak() */, L_9);
```

```c#
var cow = new Cow();
Debug.LogFormat("The cow says '{0}'", cow.Speak());
```

```c++

// 生成数组
AnimalU5BU5D_tEC503C068BC2C88521EC30D7770563984BD5F579* L_0 = (AnimalU5BU5D_tEC503C068BC2C88521EC30D7770563984BD5F579*)SZArrayNew(AnimalU5BU5D_tEC503C068BC2C88521EC30D7770563984BD5F579_il2cpp_TypeInfo_var, (uint32_t)2);

// 二次赋值
AnimalU5BU5D_tEC503C068BC2C88521EC30D7770563984BD5F579* L_1 = L_0;

// New一个Cow
Cow_tAE5FA56D932919509EF4D2E078DCA07821B318B3 * L_2 = (Cow_tAE5FA56D932919509EF4D2E078DCA07821B318B3 *)il2cpp_codegen_object_new(Cow_tAE5FA56D932919509EF4D2E078DCA07821B318B3_il2cpp_TypeInfo_var);
		Cow__ctor_m3FBB50E33B195F86F3E6237AF538BF2A5208861C(L_2, /*hidden argument*/NULL);

// Create a new cow
Cow_t1312235562 * L_14 = (Cow_t1312235562 *)il2cpp_codegen_object_new(Cow_t1312235562_il2cpp_TypeInfo_var);
Cow__ctor_m2285919473(L_14, /*hidden argument*/NULL);
V_4 = L_14;
Cow_t1312235562 * L_16 = V_4;

// cow.Speak也是通过虚函数调用的
// Call the Speak method
String_t* L_17 = VirtFuncInvoker0< String_t* >::Invoke(4 /* System.String AssemblyCSharp.Cow::Speak() */, L_16);
```

```c#
public sealed class Cow : Animal {
   public override string Speak() {
       return "Moo";
   }
}
```


##  sealed
假设我们知道在我们的农场上没有其他类型的奶牛，所以没有类型的奶牛会从奶牛中衍生出来。如果我们把这些知识明确地告诉编译器，我们可以得到一个更好的结果。让我们把这个类改为这样定义:

```c#
// sealed
// Sealed 关键字告诉编译器没有人可以从 Cow 派生(sealed 也可以直接用于 Speak 方法)。现在 IL2CPP 有信心直接调用方法:
public sealed class Cow : Animal {
   public override string Speak() {
       return "Moo";
   }
}
```

```c++
// Create a new cow
Cow_t1312235562 * L_14 = (Cow_t1312235562 *)il2cpp_codegen_object_new(Cow_t1312235562_il2cpp_TypeInfo_var);
Cow__ctor_m2285919473(L_14, /*hidden argument*/NULL);
V_4 = L_14;
Cow_t1312235562 * L_16 = V_4;

// Look ma, no virtual call!
String_t* L_17 = Cow_Speak_m1607867742(L_16, /*hidden argument*/NULL);
```

这种优化不会让你的游戏变得难以置信的快，但是对于未来的代码读者和编译器来说，表达你对代码中的任何假设都是一个很好的实践。如果您使用 IL2CPP 进行编译，我鼓励您仔细阅读项目中生成的 c + + 代码，看看还能找到什么！

下一次我们将讨论为什么虚方法调用是昂贵的，以及我们如何使它们更快。
