vnote_backup_file_826537664 I:/OneDrive/vnote_notebooks/unity3d/IL2CPP/2020.12.11_IL2CPP_FasterVirtualMethodCalls.md
# 2020.12.11_IL2CPP_FasterVirtualMethodCalls


## 调用一个虚方法需要什么？

虚方法调用是必须在运行时解析的调用。编译器在编译代码时不知道将调用哪个方法，因此它为每个类构建一个方法数组(称为虚表或 vtable)。当有人调用其中一个方法时，运行时在 vtable 中查找并调用适当的方法。但是，如果事情没有解决，而且 vtable 中没有调用虚拟方法，那么会发生什么情况呢？

## 当虚方法出错时

```c#
class BaseClass {
   public virtual string SayHello() {
       return "Hello from base!";
   }
}

class GenericDerivedClass<T> : BaseClass {
   public override string SayHello() {
       return "Hello from derived!";
   }
}
```

```c#
public class VirtualInvokeExample : MonoBehaviour {
   void Start () {
       Debug.Log(MakeRuntimeBaseClass().SayHello());
   }

   private BaseClass MakeRuntimeBaseClass() {
       var derivedType = typeof(GenericDerivedClass<>).MakeGenericType(typeof(int));
       return (BaseClass)FormatterServices.GetUninitializedObject(derivedType);
   }
}

// JIT
Hello from derived!

UnityEngine.Debug:Log(Object)
VirtualInvokeExample:Start() (at Assets/VirtualInvokeExample.cs:7)

// AOT
ExecutionEngineException: Attempting to call method 'GenericDerivedClass`1[[System.Int32, mscorlib, Version=2.0.5.0,
     Culture=, PublicKeyToken=7cec85d7bea7798e]]::SayHello' for which no ahead of time (AOT) code was generated.
  at VirtualInvokeExample.Start () [0x00000] in <filename unknown>:0
```

## 当您调用不存在的方法时

``` c++
static inline void GetVirtualInvokeData(Il2CppMethodSlot slot, void* obj, VirtualInvokeData* invokeData) {
   *invokeData = ((Il2CppObject*)obj)->klass->vtable[slot];
   if (!invokeData->methodPtr)
       RaiseExecutionEngineException(invokeData->method);
}
```

## 让我们加快代码的速度

这里只有三行代码，我们能让它更快吗？事实证明，我们可以！Vtable 查找是必要的，因此必须保持原样。但是如果支票呢？大多数情况下，条件是 false (毕竟，看看我们在运行时创建类型所需的丑陋代码，并使条件为 true)。那么，我们为什么要为代码中很少(或者永远不会)使用的分支支付成本呢？

```c++
static inline void GetVirtualInvokeData(Il2CppMethodSlot slot, void* obj, VirtualInvokeData* invokeData) {
   *invokeData = ((Il2CppObject*)obj)->klass->vtable[slot];
}

static  Il2CppObject * UnresolvedVirtualCall_2 (Il2CppObject * __this, const MethodInfo* method) {
    il2cpp_codegen_raise_execution_engine_exception(method);
    il2cpp_codegen_no_return();
}
```

## How much faster is this?

现在我们来看看底线: 这种微观优化重要吗？是的。我们的分析显示总体执行时间提高了3%-4% 。这种改进取决于虚拟调用的数量和处理器体系结构。具有更好的分支预测的处理器支付更低的 if 检查成本，因此当它被删除时，它们看到的好处更少。不处理分支预测的处理器在性能上也获得了更大的好处。


这实际上是一种常见的虚拟机优化技术，因此我们很高兴能够将其引入 IL2CPP。它遵循旧的性能准则，"不执行代码比执行某些代码更好"