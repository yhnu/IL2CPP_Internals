# 2020.12.08_IL2CPP_P_Inovke调用

(译注：P/Invoke，全称是platforminvoke service，平台调用服务，简单的说就是允许托管代码调用在 DLL 中实现的非托管函数。而在这期间一个重要的工作就是marshall：让托管代码中的数据和原生代码中的数据可以相互访问。我在下文中都称之为内存转换)


在这篇文章里，我们会讨论il2cpp.exe是如何生成在托管代码和原生代码间进行交互操作而使用到的封装函数和类型。特别的，我们将深入探讨blittable和non-blittable之间的区别，理解String，Array数据在内存上的转换，以及了解这些转换所付出的代价。

我编写托管和原生间的交互代码已经有好一段时间了，但是要让p/invoke在C#中的声明始终保持正确是一件很困难的事情。理解运行时那些对象是如何在内存上进行处理的就更加令人感觉神秘了。因为IL2CPP在这方面为我们做了绝大部分的工作，我们可以查看（甚至调试）这些内存转换行为，为我们处理问题和效率分析提供良好的支持。

这篇文章不会提供内存转换或者是原生代码交互的基础介绍。这是一个非常宽泛的话题，一篇博文根本不可能放得下。Unity的官方文档有讨论原生插件是如何与Unity交互的。Mono和Microsoft也对p/invoke提供了足够多的信息。

老生常谈了：在这个系列中，我们所探索的代码都很有可能在以后的Unity版本中发生变化。然而不管代码怎么变，其基础的概念是不会改变的。所以这个系列中的所有讨论的代码都属于实现细节。

```c++
#include <cstring>
#include <cmath>

extern "C" {
int Increment(int i) {
return i + 1;
}

bool StringsMatch(const char* l, const char* r) {
return strcmp(l, r) == 0;
}

struct Vector {
float x;
float y;
float z;
};

float ComputeLength(Vector v) {
return sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
}

void SetX(Vector* v, float value) {
v->x = value;
}

struct Boss {
char* name;
int health;
};

bool IsBossDead(Boss b) {
return b.health == 0;
}

int SumArrayElements(int* elements, int size) {
int sum = 0;
for (int i = 0; i < size; ++i) {
sum += elements[i];
}
return sum;
}

int SumBossHealth(Boss* bosses, int size) {
int sum = 0;
for (int i = 0; i < size; ++i) {
sum += bosses[i].health;
}
return sum;
}

}
```

在Unity中的托管代码仍然在HelloWorld.cs文件中：

```c#
void Start () {
Debug.Log (string.Format ("Using a blittable argument: {0}", Increment (42)));
Debug.Log (string.Format ("Marshaling strings: {0}", StringsMatch ("Hello", "Goodbye")));

var vector = new Vector (1.0f, 2.0f, 3.0f);
Debug.Log (string.Format ("Marshaling a blittable struct: {0}", ComputeLength (vector)));
SetX (ref vector, 42.0f);
Debug.Log (string.Format ("Marshaling a blittable struct by reference: {0}", vector.x));

Debug.Log (string.Format ("Marshaling a non-blittable struct: {0}", IsBossDead (new Boss("Final Boss", 100))));

int[] values = {1, 2, 3, 4};
Debug.Log(string.Format("Marshaling an array: {0}", SumArrayElements(values, values.Length)));
Boss[] bosses = {new Boss("First Boss", 25), new Boss("Second Boss", 45)};
Debug.Log(string.Format("Marshaling an array by reference: {0}", SumBossHealth(bosses, bosses.Length)));
}
```

## 为啥需要内存转换？

既然IL2CPP已经把C#代码都变成了C++代码，我们干嘛还需要从C#做内存转换到C++？虽然生成的C++代码是原生代码，但是在某些情况下，C#中数据类型的呈现还是和C++有所区别的，因此IL2CPP在运行的时候必须在两边来回转换。il2cpp.exe对数据类型和方法都会做相同的转换操作。

在托管代码层面，所有的数据类型都被分为两类：blittable或者non-blittable。blittable类型意味着在托管和原生代码中，内存的表现是一致的，没有区别（比如：byte，int，float）。Non-blittable类型在两者中的内存表现就不一致。（比如：bool，string，array）。正因为这样，blittable类型数据能够直接传递给原生代码，但是non-blittable类型就需要做转换工作了。而这个转换工作很自然的就牵扯到新内存的分配。

为了告诉托管编译器某些函数是在原生代码中实现的，**我们需要使用“extern”关键字。使用这个关键字，和“DllImport”属性相配合**，使得托管的运行时库能够找到原生中的函数并且调用他们。il2cpp.exe会为每一个extern函数产生一个封装。这层封装执行了以下一些很重要的任务：

* 为原生代码生成一个typedef以用来通过函数指针进行函数调用。
* 通过名字找到原生代码中的函数，并且将其赋值给一个函数指针如果有必要，将托管代码中的参数内存转换到原生代码格式

* It defines a typedef for the native method which is used to invoke the method via a function pointer.
* It resolves the native method by name, getting a function pointer to that method.
* It converts the arguments from their managed representation to their native representation (if necessary).
* It calls the native method.
* It converts the return value of the method from its native representation to its managed representation (if necessary).
* In converts any out or ref arguments from from their native representation to their managed representation (if necessary).

如果有必要，将原生函数的返回值内存转换到托管代码的格式如果有必要，还需要处理具有关键字是“out”或者“ref”的参数，将他们的内容从原生格式转换到托管代码格式。下面我们就来看看产生的这些封装函数都是什么个情况。


## 内存转换blittable数据类型

```c#
[DllImport("__Internal")]
private extern static int Increment(int value);
```

```c++

//31:#define DEFAULT_CALL STDCALL
//33:#define DEFAULT_CALL

//申明函数原型
extern "C" int32_t DEFAULT_CALL Increment(int32_t);

// DllImport
// System.Int32 PInokeDemo::Increment(System.Int32)
extern "C" IL2CPP_METHOD_ATTR int32_t PInokeDemo_Increment_m8720CCE207907DCC4601737D9A758022AD17D82B (int32_t ___value0, const RuntimeMethod* method)
{
	typedef int32_t (DEFAULT_CALL *PInvokeFunc) (int32_t);

    // 使用reinterpret_cast
	// Native function invocation
	int32_t returnValue = reinterpret_cast<PInvokeFunc>(Increment)(___value0);

	return returnValue;
}

// 文章的原版代码生成
extern "C" int32_t HelloWorld_Increment_m3 (Object_t * __this /*static, unused */, int32_t ___value, const MethodInfo* method)
{
    typedef int32_t (DEFAULT_CALL *PInvokeFunc) (int32_t);
    static PInvokeFunc _il2cpp_pinvoke_func;
    if (!_il2cpp_pinvoke_func)
    {
        //使用了强制转换
        _il2cpp_pinvoke_func = (PInvokeFunc)Increment;
        if (_il2cpp_pinvoke_func == NULL)
        {
            il2cpp_codegen_raise_exception(il2cpp_codegen_get_not_supported_exception("Unableto find method for p/invoke: 'Increment'"));
        }
    }
    int32_t _return_value = _il2cpp_pinvoke_func(___value);
    return _return_value;
}

```

在iOS平台上，原生函数会被静态的链接到单一的bin文件中（通过在DllImport中的“__Internal”关键字），因此IL2CPP运行时并不需要动态的查找相应的函数指针。相反，这部分工作是在link期间完成的。在其他平台上，IL2CPP可能会根据需要进行函数指针的查找。

事实情况是：在iOS平台，非正确的p/invoke在c++编译器link的阶段就会体现出来而不是等到运行时才发现。因此所有的p/invoke都必须正确，哪怕他们实际没有被执行到。
最终，原生代码通过函数指针被调用，函数的返回值被送回托管代码中。请注意在上面的例子中，参数是按值传递的，所以任何对参数值的改变都不会最终印象到托管代码中。

## 内存转换non-blittable类型

当处理non-blittable数据类型比如string的时候，事情会变得更加有趣。还记得前面文中提到的吗？在IL2CPP中string实际上是一个通过UTF-16编码的，最前面加上了一个4字节前缀的，两字节宽的数组。这种内存格式和C中的char*或者wchar_t*都不兼容，因此我们必须做一些转换。

```c#
[DllImport("__Internal")]
[return: MarshalAs(UnmanagedType.U1)]
private extern static bool StringsMatch([MarshalAs(UnmanagedType.LPStr)]string l, [MarshalAs(UnmanagedType.LPStr)]string r);
```

```c++

//Native 函数原型
extern "C" uint8_t DEFAULT_CALL StringsMatch(char*, char*);

// PInvoke
// System.Boolean PInokeDemo::StringsMatch(System.String,System.String)
extern "C" IL2CPP_METHOD_ATTR bool PInokeDemo_StringsMatch_mD5AE70C0C8E366676F35D317E96BD4D9EE3A1452 (String_t* ___l0, String_t* ___r1, const RuntimeMethod* method)
{
	typedef uint8_t (DEFAULT_CALL *PInvokeFunc) (char*, char*);

    // String需要变换为Char*
	// Marshaling of parameter U27___l0U27 to native representation
	char* ____l0_marshaled = NULL;
	____l0_marshaled = il2cpp_codegen_marshal_string(___l0);

    // String需要变换为Char*
	// Marshaling of parameter U27___r1U27 to native representation
	char* ____r1_marshaled = NULL;
	____r1_marshaled = il2cpp_codegen_marshal_string(___r1);

    // 做字符串比较
	// Native function invocation
	uint8_t returnValue = reinterpret_cast<PInvokeFunc>(StringsMatch)(____l0_marshaled, ____r1_marshaled);

    // 字符串释放
	// Marshaling cleanup of parameter U27___l0U27 native representation
	il2cpp_codegen_marshal_free(____l0_marshaled);
	____l0_marshaled = NULL;

    // 字符串释放
	// Marshaling cleanup of parameter U27___r1U27 native representation
	il2cpp_codegen_marshal_free(____r1_marshaled);
	____r1_marshaled = NULL;

	return static_cast<bool>(returnValue);
}
```

## 内存转换用户自定义类型

像int或者是string这样的类型还算好理解，那么如果有更加复杂的用户自定义类型会发生什么呢？假设我们想对有着三个float的Vector类型进行内存转换，我们会发现如果一个自定义结构中的所有成员都是blittable的话，这个类型就可以作为blittable来对待

```c#
[DllImport("__Internal")]
private extern static float ComputeLength(Vector v);
```

```c++
// PInokeDemo_Vector
struct  Vector_t42F8F537F176AD416BAA22CB3E79D4CB05E4D0E3 
{
public:
	// System.Single PInokeDemo_Vector::x
	float ___x_0;
	// System.Single PInokeDemo_Vector::y
	float ___y_1;
	// System.Single PInokeDemo_Vector::z
	float ___z_2;

public:
    //获取偏移
	inline static int32_t get_offset_of_x_0() { return static_cast<int32_t>(offsetof(Vector_t42F8F537F176AD416BAA22CB3E79D4CB05E4D0E3, ___x_0)); }
	//获取值信息
	inline float get_x_0() const { return ___x_0; }
	//获取地址信息
	inline float* get_address_of_x_0() { return &___x_0; }
	//设置值信息
	inline void set_x_0(float value)
	{
		___x_0 = value;
	}

	inline static int32_t get_offset_of_y_1() { return static_cast<int32_t>(offsetof(Vector_t42F8F537F176AD416BAA22CB3E79D4CB05E4D0E3, ___y_1)); }
	inline float get_y_1() const { return ___y_1; }
	inline float* get_address_of_y_1() { return &___y_1; }
	inline void set_y_1(float value)
	{
		___y_1 = value;
	}

	inline static int32_t get_offset_of_z_2() { return static_cast<int32_t>(offsetof(Vector_t42F8F537F176AD416BAA22CB3E79D4CB05E4D0E3, ___z_2)); }
	inline float get_z_2() const { return ___z_2; }
	inline float* get_address_of_z_2() { return &___z_2; }
	inline void set_z_2(float value)
	{
		___z_2 = value;
	}
};

//
extern "C" float DEFAULT_CALL ComputeLength(Vector_t42F8F537F176AD416BAA22CB3E79D4CB05E4D0E3 );

// System.Single PInokeDemo::ComputeLength(PInokeDemo_Vector)
extern "C" IL2CPP_METHOD_ATTR float PInokeDemo_ComputeLength_m0F91FACA52DC622F4D8DCA67B82AD5496D97E7F3 (Vector_t42F8F537F176AD416BAA22CB3E79D4CB05E4D0E3  ___v0, const RuntimeMethod* method)
{
	typedef float (DEFAULT_CALL *PInvokeFunc) (Vector_t42F8F537F176AD416BAA22CB3E79D4CB05E4D0E3 );

    //参数按值传递
	// Native function invocation
	float returnValue = reinterpret_cast<PInvokeFunc>(ComputeLength)(___v0);

	return returnValue;
}
```


## 内存转换数组

我们来看一下如果内存转换blittable和non-blittable的数组。SumArrayElements传递的是一个整数型数组，数组会进行内存转换，不过因为其每个元素都是blittable的int形，转换的代价是非常小的：

```c#
[DllImport("__Internal")]
private extern static int SumArrayElements(int[] elements, int size);
```

```c++
extern "C" int32_t DEFAULT_CALL SumArrayElements(int32_t*, int32_t);

//[ 的Unicode是U5B ]的Unicode是U5D

//
// System.Int32[]
struct Int32U5BU5D_t2B9E4FDDDB9F0A00EC0AC631BA2DA915EB1ECF83  : public RuntimeArray
{
public:
	ALIGN_FIELD (8) int32_t m_Items[1];

public:
	inline int32_t GetAt(il2cpp_array_size_t index) const
	{
		IL2CPP_ARRAY_BOUNDS_CHECK(index, (uint32_t)(this)->max_length);
		return m_Items[index];
	}
	inline int32_t* GetAddressAt(il2cpp_array_size_t index)
	{
		IL2CPP_ARRAY_BOUNDS_CHECK(index, (uint32_t)(this)->max_length);
		return m_Items + index;
	}
	inline void SetAt(il2cpp_array_size_t index, int32_t value)
	{
		IL2CPP_ARRAY_BOUNDS_CHECK(index, (uint32_t)(this)->max_length);
		m_Items[index] = value;
	}
	inline int32_t GetAtUnchecked(il2cpp_array_size_t index) const
	{
		return m_Items[index];
	}
	inline int32_t* GetAddressAtUnchecked(il2cpp_array_size_t index)
	{
		return m_Items + index;
	}
	inline void SetAtUnchecked(il2cpp_array_size_t index, int32_t value)
	{
		m_Items[index] = value;
	}
};

// System.Int32 PInokeDemo::SumArrayElements(System.Int32[],System.Int32)
extern "C" IL2CPP_METHOD_ATTR int32_t PInokeDemo_SumArrayElements_mA499DAED1106E0DB0D50FD74CB14E6CB86A55B63 (Int32U5BU5D_t2B9E4FDDDB9F0A00EC0AC631BA2DA915EB1ECF83* ___elements0, int32_t ___size1, const RuntimeMethod* method)
{
	typedef int32_t (DEFAULT_CALL *PInvokeFunc) (int32_t*, int32_t);

	// Marshaling of parameter U27___elements0U27 to native representation
	int32_t* ____elements0_marshaled = NULL;
	if (___elements0 != NULL)
	{
		____elements0_marshaled = reinterpret_cast<int32_t*>((___elements0)->GetAddressAtUnchecked(0));
	}

	// Native function invocation
	int32_t returnValue = reinterpret_cast<PInvokeFunc>(SumArrayElements)(____elements0_marshaled, ___size1);

	return returnValue;
}
```


### 内存转换non-blittable类型的数组开销就会大很多

```c#
struct Boss
{
    public string name;
    public int health;

    public Boss(string v1, int v2) : this()
    {
        this.name = v1;
        this.health = v2;
    }
};
```


```c++

// Boss的类型定义，使用了2种类型，一种为Com接口，一种为P/Invoke
// Native definition for P/Invoke marshalling of PInokeDemo/Boss
struct Boss_t4DFCA8B70274E8A527C98C58DFBFAC4530831020_marshaled_pinvoke
{
	char* ___name_0;
	int32_t ___health_1;
};

// Native definition for COM marshalling of PInokeDemo/Boss
struct Boss_t4DFCA8B70274E8A527C98C58DFBFAC4530831020_marshaled_com
{
	Il2CppChar* ___name_0;
	int32_t ___health_1;
};

extern "C" float DEFAULT_CALL SumBossHealth(Boss_t4DFCA8B70274E8A527C98C58DFBFAC4530831020_marshaled_pinvoke*, int32_t);
// System.Single PInokeDemo::SumBossHealth(PInokeDemo_Boss[],System.Int32)
extern "C" IL2CPP_METHOD_ATTR float PInokeDemo_SumBossHealth_mF466555F6E347A8138B91E854F2058576F595624 (BossU5BU5D_t732B317799F37FFEDE8CA5EE7CEFD0D447C6A6AE* ___b0, int32_t ___len1, const RuntimeMethod* method)
{


	typedef float (DEFAULT_CALL *PInvokeFunc) (Boss_t4DFCA8B70274E8A527C98C58DFBFAC4530831020_marshaled_pinvoke*, int32_t);
	// Marshaling of parameter U27___b0U27 to native representation
	Boss_t4DFCA8B70274E8A527C98C58DFBFAC4530831020_marshaled_pinvoke* ____b0_marshaled = NULL;
	if (___b0 != NULL)
	{
		il2cpp_array_size_t ____b0_Length = (___b0)->max_length;
		
		//内存申请
		____b0_marshaled = il2cpp_codegen_marshal_allocate_array<Boss_t4DFCA8B70274E8A527C98C58DFBFAC4530831020_marshaled_pinvoke>(____b0_Length);
		for (int32_t i = 0; i < ARRAY_LENGTH_AS_INT32(____b0_Length); i++)
		{
		    //内存转换
			Boss_t4DFCA8B70274E8A527C98C58DFBFAC4530831020_marshal_pinvoke((___b0)->GetAtUnchecked(static_cast<il2cpp_array_size_t>(i)), (____b0_marshaled)[i]);
		}
	}
	else
	{
		____b0_marshaled = NULL;
	}
    
    // 函数调用
	// Native function invocation
	float returnValue = reinterpret_cast<PInvokeFunc>(SumBossHealth)(____b0_marshaled, ___len1);

    // 内存释放
	// Marshaling cleanup of parameter U27___b0U27 native representation
	if (____b0_marshaled != NULL)
	{
		const il2cpp_array_size_t ____b0_marshaled_CleanupLoopCount = (___b0 != NULL) ? (___b0)->max_length : 0;
		for (int32_t i = 0; i < ARRAY_LENGTH_AS_INT32(____b0_marshaled_CleanupLoopCount); i++)
		{
			Boss_t4DFCA8B70274E8A527C98C58DFBFAC4530831020_marshal_pinvoke_cleanup((____b0_marshaled)[i]);
		}
		il2cpp_codegen_marshal_free(____b0_marshaled);
		____b0_marshaled = NULL;
	}

	return returnValue;
}
```

结论

在内存转换上， IL2CPP的行为和Mono是一致的。因为IL2CPP会对extern函数和类型产生封装代码，因此我们可以检查交互调用的开销。对于blittable而言，开销通常还好，但是对于non-blittable而言，会让开销上升的很快。我们只是对内存转换做了个简单的介绍。有关返回值和带out关键字的参数，原生函数指针和托管中的代理，用户自定义的引用类型的内存转换，还请大家探索源码自行分析




